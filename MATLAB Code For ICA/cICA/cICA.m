function [y, w] = cICA(X, ref, threshold, w0, learningRate, mu0, lambda0, gamma, maxIter, OverValue)
% Constrained ICA for extracting one source signal using the reference signal.
%
% Command:
%   [y, w] = cICA(X, ref, threshold, w0, learningRate, mu0, lambda0, gamma, maxIter, OverValue)£»
%
% Parameters:
%            y --- extracted source signal, according to the given optimal time delay.
%            w --- corresponding weight vector, that is, y=w'*X.
%            X --- prewhitened observed mixed signals. Each row is a mixed signal.     
%          ref --- reference signal, which can be generated by function genRectangleRef
%                  and genPulseRef
%    threshold --- the closeness of the desired signal and the reference signal is less than 
%                  or equal to the threshold, i.e., closeness(y,ref) - threshold <= 0
%           w0 --- the initial weight vector
% learningRate --- learning rate of the weight w
%          mu0 --- the Lagrange multiplier for constraint g(w)
%      lambda0 --- the Lagrange multiplier for constraint h(w)
%        gamma --- the scalar penalty parameter
%  OverValue --- stopping criterion, say, 0.0001. When the changed value 
%                of weighted vector is less than it, then the algorithm stops
%    maxIter --- maximum iterations for estimating each independent component
%
% See also:
%    genPulseRef     genRectangleRef     cICAdemo
%
% Reference:
%    [1] Wei Lu, Jagath C. Rajapakse: ICA with reference. ICA 2001
%    [2] Zhi-Lin Zhang, Morphologically Constrained ICA for Extracting Weak Temporally 
%        Correlated Signals, Neurocomputing 71(7-9) (2008) 1669-1679
%
% Author: Zhilin Zhang
%         z4zhang@ucsd.edu
%
% version: 1.0     Date: Dec.14,2008
% 


fprintf('Starting cICA for extracting the desired source signal ..\n');
[ICnum, IClen]=size(X);

w = w0;
oldw = w;

mu = mu0;
lambda = lambda0;

flag = 1;
loop = 1;

% compute the autocorrelation matrix Rxx
Rxx = X(:,[1:end]) * X(:,[1:end])' / IClen;
    
while (flag == 1)
    
    % output at current iteration
    y = w' * X;       
    
    % calculate the first order deviation of the Lagarange function
    std_y = std(y);                          % standard deviation
    v_Gaus = normrnd(0, std_y, 1, IClen);    % Gaussian signal with the same mean and variance
    rou = mean( log(cosh(y)) - log(cosh(v_Gaus)) );
    L1 = sign(rou) * ( X * tanh(y)')/IClen - mu * ( X * (y - ref)')/IClen ...
        - lambda * ( X * y')/IClen;
    
    % related to the second order deviation of the Lagarange function
    Sw = sign(rou) * mean(1-tanh(y).^2) - mu - lambda;

    % update of the weight vector
    w = w - learningRate * inv(Rxx) * L1 / Sw;
%     w = w - learningRate * L1 / Sw;
    w = w/norm(w);
    
    % update of the parameter mu
    thr = threshold * (1-exp(-loop));
    thr = threshold;
    g = mean( (y-ref).^2 ) - thr;    % corresponds to the inequality constraint
    mu = max(0, mu + gamma * g);

    % update of the parameter lambda
    h = mean(y.^2) - 1;                    % corresponds to the equality constraint
    lambda = lambda + gamma * h;


    % decide whether the algorithm has converged or not
    wchange = 1-abs(w'*oldw);
    fprintf('No.%d iteration: change in w is %g\n',loop, wchange);
    if wchange < OverValue
        fprintf('Converged after %d iteration\n',loop);
        flag = 0;
    end

    if loop >= maxIter
        fprintf('After %d iteration, still cannot convergent.\n',loop);
        flag = 0;
    end

    oldw = w;
    loop = loop + 1;

end

% output
y = w'* X;

fprintf('End of cICA algorithm !\n');
